# 面向对象和JS中的面向对象

## 面向对象 - 《面向对象分析与设计》总结

- 对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。
- 对象有状态：对象具有状态，同一对象可能处于不同状态之下。
- 对象具有行为：即对象的状态，可能因为它的行为产生变迁。

## JS对象的特征

- 标识性：JS中对象都是通过内存地址来存储，一般别的语言也一样。
- 有状态，具有行为：JS中，将状态和行为统一抽象为属性，包括函数也式一种特殊对象。

- JS对象中还有独有的特色：对象具有高度的动态性，这是因为 JavaScript 赋予了使用者在运行时为对象添改状态和行为的能力。

### 高度的动态性

- 数据属性：比较接近于其它语言的属性概念
  - value：就是属性的值。
  - writable：决定属性能否被赋值。
  - enumerable：决定 for in 能否枚举该属性。
  - configurable：决定该属性能否被删除或者改变特征值。

- 访问器属性：
  - getter：函数或 undefined，在取属性值时被调用。
  - setter：函数或 undefined，在设置属性值时被调用。
  - enumerable：决定 for in 能否枚举该属性。
  - configurable：决定该属性能否被删除或者改变特征值。

- 可以通过`Object.getOwnPropertyDescripter`查看。

## 虽然JS的对象系统设计很特别，但JS也提供了完全运行时的对象系统，使得它可以模仿多数面向对象编程方式。

## JavaScript 语言标准也已经明确说明，JavaScript 是一门面向对象的语言

# 面向对象不等于面向类

- JS之初，Brendan透露过，最初的构想是一个拥有基于原型的面向对象能力的scheme语言。
- JS之前，原型系统久更多与高动态性语言配合，多数基于原型的语言提倡运行时的原型修改。
- 无论是基于类或者基于原型，都能够满足基本的复用和抽象需求

## 基于类
- 编程提倡使用一个关注分类和类之间关系开发模型。总是先有类，再从类去实例化一个对象。类与类之间又可能会形成继承、组合等关系。
- 类又往往与语言的类型系统整合，形成一定编译时的能力。

## 基于原型
- 更为提倡程序员去关注一系列对象实例的行为，而后才去关心如何将这些对象，划分到最近的使用方式相似的原型对象，而不是将它们分成类。
- 基于原型的面向对象系统通过“复制”的方式来创建新对象。

- 原型系统的复制操作，有两种实现思路
  - 一个是并不真的去复制一个原型对象，而是使得新对象持有一个原型的引用；（JS）
  - 另一个是切实地复制对象，从此两个对象再无关联。


## JS的原型系统
- 如果所有对象都有私有字段 [[prototype]]，就是对象的原型；
- 读一个属性，如果对象本身没有，则会继续访问对象的原型，直到原型为空或者找到为止。

- ES6 以来，JavaScript 提供了一系列内置函数，以便更为直接地访问操纵原型。「可以完全抛开类的思维，利用原型来实现抽象和复用。」
  - Object.create 根据指定的原型创建新对象，原型可以是 null；
  - Object.getPrototypeOf 获得一个对象的原型；
  - Object.setPrototypeOf 设置一个对象的原型。

- 在更早的版本中，程序员只能通过 Java 风格的类接口来操纵原型运行时，例如：`new, prototype`

## 早期的类和原型
- 在早期版本的 JavaScript 中，“类”的定义是一个私有属性 [[class]]。语言标准为内置类型诸如 Number、String、Date 等指定了 [[class]] 属性，以表示它们的类。语言使用者唯一可以访问 [[class]] 属性的方式是 Object.prototype.toString。

- 所以，在ES3 和之前的版本，JS 中类的概念是相当弱的，它仅仅是运行时的一个字符串属性。

- ES5 开始，[[class]] 私有属性被 Symbol.toStringTag 代替。Object.prototype.toString 的意义从命名上不再跟 class 相关。（可以重写[Symbol.toStringTag]的方法）

### 关于类中的new

- 做了什么事：
  - new 运算接受一个构造器和一组调用参数
  - 以构造器的 prototype 属性（注意与私有字段 [[prototype]] 的区分）为原型，创建新对象
  - 将 this 和调用参数传给构造器，执行；
  - 如果构造器返回的是对象，则返回，否则返回第一步创建的对象。

- 试图让函数对象在语法上和类变得类似，本质上new提供了两种方式：
  - 在构造器中添加属性。例如：直接在构造器中修改this，给this添加属性
  - 二是在构造器的 prototype 属性上添加属性。修改构造器prototype属性指向的对象。
    ```js
    // 没有 Object.create、Object.setPrototypeOf 的早期版本中，new 运算是唯一一个可以指定 [[prototype]] 的方法，还有多数浏览器不支持的 __proto__
    function c1(){
      this.p1 = 1;
      this.p2 = function(){
          console.log(this.p1);
      }
    } 
    var o1 = new c1;
    o1.p2();
    
    function c2(){
    }
    c2.prototype.p1 = 1;
    c2.prototype.p2 = function(){
        console.log(this.p1);
    }
    
    var o2 = new c2;
    o2.p2();
    ```

### ES6中的类
- 新特性 class 可以让 new 和 function 的搭配退休啦。
- 在标准中删除了所有 [[class]] 相关的私有属性描述，类的概念正式从属性升级成语言的基础设施。

- 除了getter/setter 和 method外，还提供了继承能力。

# 对象分类

## 宿主对象：由 JavaScript 宿主环境提供的对象。

## 内置对象：由 JavaScript 语言提供的对象:

### 固有对象（Intrinsic Objects ）：
- 由标准规定，随着 JavaScript 运行时创建而自动创建的对象实例。通常扮演者类似基础库的角色。

### 原生对象（Native Objects）：
- 可以由用户通过 Array、RegExp 等内置构造器或者特殊语法创建的对象, 我们可以用 new 运算创建新的对象。
- ![](/image/67da86dd816514b485a0b2f7dcb72dd.png)
- 几乎所有这些构造器的能力都是无法用纯 JavaScript 代码实现的，它们也无法用 class/extend 语法来继承，由于这些构造器创建的对象多数使用了私有字段。所有这些原生对象都是为了特定能力或者性能，而设计出来的“特权对象”。
```JS
Error: [[ErrorData]]
Boolean: [[BooleanData]]
```
### 普通对象（Ordinary Objects）：
- 由 {} 语法、Object 构造器或者 class 关键字定义类创建的对象，它能够被原型继承。

## 使用对象模拟函数与构造器 - 函数对象与构造器对象
- 函数对象的定义是：具有 [[call]] 私有字段的对象
- 构造器对象的定义是：具有私有字段 [[construct]] 的对象。

- JS用对象模拟函数的设计替代了一般语言的函数，只要具有[[call]]私有字段，都可以被JS函数调用语法支持。
  - PS：[call]] 私有字段必须是一个引擎中定义的函数，需要接受 this 值和调用参数，并且会产生域的切换

- 用 function 关键字创建的函数必定同时是函数和构造器。不过，它们表现出来的行为效果却并不相同。比如：
  - 内置对象 Date 在作为构造器调用时产生新的对象，作为函数时，则产生字符串；
  - 基本类型（String、Number、Boolean），它们的构造器被当作函数调用，则产生类型转换的效果

- ES6的箭头函数，创建的仅仅是函数，无法被作为构造器使用。

## 一些特殊行为的对象
- Array：Array 的 length 属性根据最大的下标自动发生变化。
- Object.prototype：作为所有正常对象的默认原型，不能再给它设置原型了。
- String：为了支持下标运算，String 的正整数属性访问会去字符串里查找。
- Arguments：arguments 的非负整数型下标属性跟对应的变量联动。
- 模块的 namespace 对象：特殊的地方非常多，跟一般对象完全不一样，尽量只用于 import 吧。
- 类型数组和数组缓冲区：跟内存块相关联，下标运算比较特殊。
- bind 后的 function：跟原来的函数相关联。

